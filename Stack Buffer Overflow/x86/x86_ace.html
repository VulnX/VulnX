<html>
<head>
<link rel="icon" href="https://www.vulnx.in/favicon.png">	
<script data-ad-client="ca-pub-6203666289882469" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {margin: 0;}

#myCookieConsent {
    border-radius: 5px;
    border: 5px solid #f44336;
    width: 80%;
    padding: 20px 20px;
    overflow: hidden;
    position: fixed;
    color: #fff;
    bottom: 3px;
    display: none;
    left: 5%;
    text-align: center;
    font-size: 15px;
    font-weight: bold;
}

#myCookieConsent #cookieButton {
    display: inline-block;
    color: #fff;
    font-size: 1.1em;
    background: #000;
    text-decoration: none;
    cursor: pointer;
    padding: 2px 20px;
    float: right;
    border: 2px solid #f44336;
    border-radius: 5px;
    transition: 0.5s;
}
#myCookieConsent #cookieButton:hover {
    border: 2px solid white;
    background: #f44336;
	color: #fff;
}

ul.topnav {
  list-style-type: none;
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #23252e;
}

ul.topnav li {float: left;}

ul.topnav li a {
  background-color: #23252e;
  display: block;
  color: white;
  text-align: center;
  padding: 16px 16px;
  text-decoration: none;
}

ul.topnav li a:hover:not(.active) {background-color: #f44336;}

ul.topnav li a.active {background-color: #4CAF50;}

@media screen and (max-width: 600px) {
  ul.topnav li.left, 
  ul.topnav li {float: none;}
}
</style>
<link rel="stylesheet" href="style.css"/>
<link href="https://fonts.googleapis.com/css?family=Fira+Code:600|Lobster&display=swap" rel="stylesheet">
<title>Buffer Overflow : Part-3. x86_ace | VulnX</title>
</head>
<body>
<font color="white" face="Fira Code" size="3">	
<ul class="topnav">
<li><a href="../../../../../../../../../index.html">Home</a></li>
<li><a href="../../../../../../../../../Contents/resources.html">Resources</a></li>
<li><a href="../../../../../../../../../Contents/tutorials.html">Tutorials</a></li>
<li><a href="../../../../../../../../../Contents/CTFs.html">CTFs</a></li>
</ul>
</font>
<div id="align">
<font color="white" face="Fira Code" size="2">
<div id="myCookieConsent">
	<div id="cookieButton">I agree</div>
	<div>By using our site, you agree to our use of cookies to deliver a better site experience.</div>
</div>

<script>
var obj;
obj = document.getElementById("myCookieConsent");

function  func() {
	obj.style.display = "none";
	document.cookie = "cookiePromptShown=Yes; path=/";
}
var element;
element = document.getElementById("cookieButton");
element.addEventListener('click', func);
</script>
</font>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-167461836-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-167461836-1');
</script>

<font color="white" face="Fira Code" size="2">
<center><h1>Buffer Overflow</h1></center>
<center><h1>PART-3 : x86_ace</h1></center>
Hello and welcome everybody to the third part of Buffer Overflow series. In the previous tutorials, we discovered how, if we overwrite the EIP or RIP to the base address of the function to be called, we can redirect execution to that function. Now we are moving a step ahead, in this part we will be learning how to execute our code which is not available in the C program. Of course we want to get a reverse root shell, but the programmer of the software is not dumb to put this function his/her source code just so that we can call that function. So now the challenge is that, there is not function for us to call. Alright, so we can easily bypass this barrier by using RCE or ACE which stands for Remote Code Execution or Arbitrary Code Execution. In this technique we will be executing our own code by using a shellcode [ from msfvenom ]. So you might wonder what is a shellcode? A shellcode is basically is piece code used as the payload in the exploitation, and a shellcode is commonly written 
in machine code.<br><br>

<hr noshade color="white">
<b>AIM - To print the date and time. [ execute -> '/bin/date' ].</b>
<hr noshade color="white">

<br>
<h1><u>STEP 1 -	Identification of vulnerability</u></h1>
Firstly let's use a small C program, which will have no extra function for us to call.<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace.c_source.png" class="responsive">
</div><br>

Okay! So the code is quite simple, as soon as we execute the program, the EIP [ since this tutorial will be on a 32-bit or x86 machine ] will jump to main function and the main will redirect it to 'vuln' function. There it will allocate 500 bytes for 'text' variable. After that's done, it will print a message and wait for input, once the user supplies some string to the program, the program will store it in the 'text' variable. Once again, we are using the `gets` function. So we are sure that there is a vulnerability of buffer overflow.<br><br>

Now let's compile our program :-<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_compiling_output.png" class="responsive">
</div><br>

Okay here we have used two flag:
<ul>
	<li><b>-m32</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ->	We are using this flag to compile this program for a 32-bit machine [ ignore this flag in case you are already on a 32-bit OS ]</li>
	<li><b>-z execstack</b> ->	This flag makes the stack executable, if you think why do we need to do this, umm well.. I'll explain later in the tutorial.</li>
</ul>

Ok now that have our compiled binary, let's test it.<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_test.png" class="responsive">
</div><br>

Great!! It works fine, now let's feed it with 1000 characters.<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_first_seg_fault.png" class="responsive">
</div><br>

Alright, we got our seg fault and this means that we can overflow the buffer to execute our shellcode.<br>

<h1><u>STEP 2 -	Determination of offset</u></h1>

Now let's quickly use metasploit's scripts to get the offset. Firstly let's generate 1000 characters: :-<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_msf-pattern_create.png" class="responsive">
</div><br>

Okay! Here we echo all those 1000 characters into a file called 'offset.in'. Now let's start a GDB session with our compiled binary with this file as input and identify where the EIP is pointing.<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_overflowed_eip.png" class="responsive">
</div><br>

Very well the EIP is pointing to '0x31724130', now let's determine the offset :-<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_msf-pattern_offset.png" class="responsive">
</div><br>

Okay we got the offset of EIP [ == 512 ], now the question is where should we make the EIP point to? Well ... think about it!<br><br><br>
<h1><u>STEP 3 -	Find where to place the shellcode and where should the EIP point to</u></h1>

Well the answer is stack! The stack is empty and can be filled with our input [ in our case, the shellcode will be the input ]. Let's write 512 times 'A' followed by 4 times 'B' to 'offset.in'.<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_echo_516_chars.png" class="responsive">
</div><br>

Okay great now start a GDB session and type this command :-<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_disass_main.png" class="responsive">
</div><br>

Over here we can clearly see that the system makes a call to the 'vuln' function. Exactly how we had programmed in our source code. Now let's disassemble 'vuln' function :-<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_disass_vuln.png" class="responsive">
</div><br>

Okay a lot of stuff is going around here. Some things we can observe is that first there a call to the printf function probably for the 'Enter some text: ' string. Then there is a call to the gets function. After that there is a call to printf again probably for 'You typed : %s\n' string. Okay let's place a breakpoint just after the gets function. So that as soon as we supply input to the program and the program stores it in the 'text' variable, the program will pause at that stage and then we can analyse the binary.<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_set_breakpoint.png" class="responsive">
</div><br>

Okay now let's feed it with our 'offset.in' :-<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_run_with_offset.in.png" class="responsive">
</div><br>

As you can see the program has been fed with our input and it has stopped at '0x565561df'. Now let's view some data from the stack [ or more precisely the ESP ] :-<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_stack_overview_of_bytes.png" class="responsive">
</div><br>

Okay in the command the first 'x' means examine and then the '/150' means 150 values and the last 'x' means the values are to be displayed as hex and the '$esp' means 'from ESP'. So the command basically means, 'Examine and display 150 values from the Stack in Hexadecimal format'. Alright aside from the translation, this part is very important as well as tricky. So basically here we can see 512 bytes of 'A' and 4 bytes of 'B' are on the stack. So this means that our input is stored directly on the stack. So if we supply the shellcode to the program as input then even the shellcode will be on the stack. So we can overwrite the instruction pointer and redirect execution to the start of the shellcode. But here there are two problems.<br>

<ul>
	<li>First - What if the shellcode is not of 512 bytes?<br>The format of our payload is -> shellcode[512 bytes] + EIP<br>The problem here is that the shellcode will not always be of 512 bytes. Assuming the shellcode to be 100 bytes, then the EIP [4 bytes] will be written on the stack and will not cause overflow as the length of our input has not reached the offset, this is because the total length of payload will be 100 + 4 => 104, whereas offset is 512. We can overcome this by using a shellcode which is less than 512 bytes and filling the rest of the bytes with junk characters like 'A'. So if X is the number of bytes of shellcode, then 'A' will be 512 - X times.</li>
	<li>Second - Wrong pointing of EIP due to randomization.<br>Since we are performing this exploit on a modern computer, so by default ASLR will be enabled and it will randomize the address. Suppose we calc. that the EIP must point to 0xFFFFFF0D on the stack, and here ASLR takes it's place and randomizes that location to be 0xFFFFFF04. Here our EIP points to the wrong address and so our shellcode isn't executed.</li>
</ul>

The below diagram depicts how our payload will work when ASLR is disabled:<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_diagram_before_randomization.png" class="responsive">
</div><br>

And here is the diagram which shows how our EIP will point to the wrong address when ASLR is enabled:<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_diagram_after_randomization.png" class="responsive">
</div><br>

In the above image we have set the EIP to point to '0xFFFFFF0D', however, because ASLR randomly shuffles the memory addresses now our shellcode is at '0xFFFFFF04' and thus our execution is redirected to the wrong location on the stack.<br><br>

There is a very interesting method to overcome this situation. We can use <b><u>NOP</u></b> which is an abbreviation for 'No Operation'. The name is quite self-explanatory. This function has hex code "0x90". Whenever we place this on the stack, it does nothing, it simply slides the instruction pointer to the end of the NOP. You can assume the NOP to be a 'comment' on the stack, where the comment has no function, it is just occupying space. Well this part again very important. We can overcome randomization by using NOPs. If we make the EIP point to somewhere in the NOP then, our program will not perform any operation, instead if we place the shellcode after the NOPs, then the instruction pointer will slide all the way down to the start of our shellcode. For this we need to place a lot of NOPs on the stack. Assuming we make the EIP point to 0xFFFFFF0A [ begining of NOPs ] and after randomization that location is shifted somewhere else, since we have a large number NOPs on the stack we have a greater chance that the randomized address will be somewhere in the NOP itself, like for example after randomization the NOPs start at 0xFFFFFF03 and the address 0xFFFFFF0A is somewhere in the middle of the NOPs, even then our shellcode will be executed, since our EIP has been redirected to the NOPs and thus it will ultimately slide to the end [ or the begining of shellcode ]. In case our NOPs end before the randomized address, then the EIP points to the wrong address again and we fail. So in that situation we need to increase the length of the NOP such that somehow a part of our NOPs lie at the randomized address. So we can conclude that our payload layout is like:<br><br>

<b>NOPs [ in large numbers like 128 bytes ] + shellcode [ X bytes {less than 512} ] + padding [ 512 - (128 + X) bytes ] + EIP [ 4 bytes ]</b><br><br>

Okay if you have managed to understand things so far <b>[ without skipping parts ]</b>, you will very likely understand the rest easily.<br>

So take a look at the image below, it's the same stack image:<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_stack_overview_ret_addr.png" class="responsive">
</div><br>

Since our first 128 bytes will contain NOPs so we can redirect EIP to any memory address in the first 128 bytes. Over here I will choose '0xffffd010' as the ret address [ the one to which we want to redirect execution ].<br>Now we know everything except for shellcode from our payload<br><br>

<b>NOTE : In the shellcode you must avoid using \x00 [ NULL-BYTE ] as it is a badchar and it will terminate our shellcode at that point, and will force the system to quit at that moment instead of executing the rest.</b><br>

<h1><u>STEP 3 -	Crafting the payload</u></h1>

Let's quickly create a file called 'payload.py', this python file will contain our NOPs, shellcode, padding, and EIP.<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_incomplete_payload.py_source.png" class="responsive">
</div><br>

In the above script change '0xffffd010' to the ret address in your case.<br>Now we will generate a shellcode using msfvenom which prints date and time [ or basically let's just call /bin/date ].<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_msfvenom.png" class="responsive">
</div><br>

Now quickly copy the shellcode and place them in your script. Also add the print func like this:<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_complete_payload.py_source.png" class="responsive">
</div><br>

Alright, now let's see the output and store it in a file called 'input.txt':<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_output_of_payload.py.png" class="responsive">
</div><br>

Okay good, now you know that our shellcode will be placed on our stack, and in order for the shellcode to execute, the stack must be executable. If you remember earlier in this tutorial I had said "umm well.. I'll explain later in the tutorial". Alright now you know why we had added the '-z execstack' flag while compiling our C program.<br><br>

Anway, we have successfully crafted the payload script and stored it's output in 'input.txt'. Now let's feed input to our binary through 'input.txt' in GDB and check for execution of our shellcode:<br><br>
<div id="image">
<img src="../../../../../../../../../Stack Buffer Overflow/x86/images/x86_ace_shellcode_executed.png" class="responsive">
</div><br>

PWNED!! Great we have successfully executed our custom shellcode. Now you very well know how to execute shellcodes on stack.<br>

<br>
Now that you have understood the concept of Arbitrary Code Execution, I highly encourage you to write your own script and exploit it with different shellcode!!<br>
<br>
<div id="align_right">
Good Luck,<br>
VulnX
<br>
</div>
<hr class="new5">
</font>
</div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script>
var element;
element = document.getElementById("myCookieConsent");

function getCookie(cname) {
  var name = cname + "=";
  var decodedCookie = decodeURIComponent(document.cookie);
  var ca = decodedCookie.split(';');
  for(var i = 0; i <ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
}

 var cookieVal = getCookie("cookiePromptShown");

if(cookieVal != "Yes") {
	element.style.display = "block";
}
else {
	element.style.display = "none";
}

</script>

</body>
</html>
