<html>
<head>
<link rel="icon" href="https://www.vulnx.in/favicon.png">	
<script data-ad-client="ca-pub-6203666289882469" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {margin: 0;}

#myCookieConsent {
    border-radius: 5px;
    border: 5px solid #f44336;
    width: 80%;
    padding: 20px 20px;
    overflow: hidden;
    position: fixed;
    color: #fff;
    bottom: 3px;
    display: none;
    left: 5%;
    text-align: center;
    font-size: 15px;
    font-weight: bold;
}

#myCookieConsent #cookieButton {
    display: inline-block;
    color: #fff;
    font-size: 1.1em;
    background: #000;
    text-decoration: none;
    cursor: pointer;
    padding: 2px 20px;
    float: right;
    border: 2px solid #f44336;
    border-radius: 5px;
    transition: 0.5s;
}
#myCookieConsent #cookieButton:hover {
    border: 2px solid white;
    background: #f44336;
	color: #fff;
}

ul.topnav {
  list-style-type: none;
  margin: 0;
  padding: 0;
  overflow: hidden;
  background-color: #23252e;
}

ul.topnav li {float: left;}

ul.topnav li a {
  background-color: #23252e;
  display: block;
  color: white;
  text-align: center;
  padding: 16px 16px;
  text-decoration: none;
}

ul.topnav li a:hover:not(.active) {background-color: #f44336;}

ul.topnav li a.active {background-color: #4CAF50;}

@media screen and (max-width: 600px) {
  ul.topnav li.left, 
  ul.topnav li {float: none;}
}
</style>
<link rel="stylesheet" href="style.css"/>
<link href="https://fonts.googleapis.com/css?family=Fira+Code:600|Lobster&display=swap" rel="stylesheet">
<title>Buffer Overflow : Part-4. x64_ace | VulnX</title>
</head>
<body>
<font color="white" face="Fira Code" size="3">	
<ul class="topnav">
<li><a href="../../../../../../../../../index.html">Home</a></li>
<li><a href="../../../../../../../../../Contents/resources.html">Resources</a></li>
<li><a href="../../../../../../../../../Contents/tutorials.html">Tutorials</a></li>
<li><a href="../../../../../../../../../Contents/CTFs.html">CTFs</a></li>
</ul>
</font>
<div id="align">
<font color="white" face="Fira Code" size="2">
<div id="myCookieConsent">
	<div id="cookieButton">I agree</div>
	<div>By using our site, you agree to our use of cookies to deliver a better site experience.</div>
</div>

<script>
var obj;
obj = document.getElementById("myCookieConsent");

function  func() {
	obj.style.display = "none";
	document.cookie = "cookiePromptShown=Yes; path=/";
}
var element;
element = document.getElementById("cookieButton");
element.addEventListener('click', func);
</script>
</font>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-167461836-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-167461836-1');
</script>

<font color="white" face="Fira Code" size="2">
<center><h1>Buffer Overflow</h1></center>
<center><h1>PART-4 : x64_ace</h1></center>
Hello and welcome everybody to the fourth part of Buffer Overflow series. In the previous tutorial, we discovered how, if we place the shellcode on the stack and fill the return pointer [ EIP ] with the starting address of the shellcode, we can execute arbitrary code which is not provided in the compiled application. This creates dangerous security holes. In this tutorial we will see how we can adapt that exploit on a modern 64-bit system!<br><br>

<hr noshade color="white">
<b>AIM - To print the date and time. [ execute -> '/bin/date' ].</b>
<hr noshade color="white">

So in this tutorial, we will use the same script as the previous one
<br><br><div id="image">
	<img src="../x86/images/x86_ace.c_source.png" class="responsive">
</div><br>

As you can clearly see over here, we do not have an extra function which prints the date and time, so it seems clear that we have to use a shellcode to execute remote code. We can use the 'gets' function to store user input data [ shellcode ] on the stack and overwrite the RIP to the start of the shellcode.<br><br>

So let's start by compiling the application :-
<br><br><div id="image">
	<img src="images/x64_ace_compiling.png" class="responsive">
</div><br> 

So here we are using two flags :-<br>
<ul>
	<li>-z execstack --> This will make the stack executable. We need this because our shellcode will be placed on the stack, therfore to execute it, the stack must be executable.</li>
	<li>-no-pie &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--> ASLR works much better on a 64-bit OS, so for the sake of simplicity it's better to disable it. Using this flag will disable ASLR on the program.</li>
</ul>

And we have a compiled application, 'x64_ace'. Let's quickly test this program.
<br><br><div id="image">
	<img src="images/x64_ace_test1.png" class="responsive">
</div><br> 

The program works exactly how it was supposed to! Great, now let's try feeding 1000 characters to it!
<br><br><div id="image">
	<img src="images/x64_ace_segfault.png" class="responsive">
</div><br> 

Perfect, we have written data outside the buffer, and that's why we get the seg fault! Now without wasting further time let's quickly determine the offset using metasploit & GDB!
<br><br><div id="image">
	<img src="images/x64_ace_identify_rbp.png" class="responsive">
</div><br>

Remember to determine the offset using RBP in a x64 OS.
<br><br><div id="image">
	<img src="images/x64_ace_rbp_offset.png" class="responsive">
</div><br>

Okay we got the offset as 512, however, this is not correct because this is the offset of RBP and the RIP lies 8 bytes ahead of the RBP [ since registers are of 8-bits in a x64 OS ], thus the offset for RIP is : <b>512 + 8 == 520</b><br><br>

Now let's see where we can place the shellcode on the stack.
<br><br><div id="image">
	<img src="images/x64_ace_break_set.png" class="responsive">
</div><br>

You can see I have set a breakpoint just after the 'gets' function is called. So when the user supplies input to the program, & the program stores it onto the stack, immediately after that we hit the breakpoint.<br>
You can look at the snapshot provided below which shows that I have entered a bunch of upper case 'A' to the program.
<br><br><div id="image">
	<img src="images/x64_ace_break_hit.png" class="responsive">
</div><br>

Now if we examine and print 150 values as hex from the stack, you can see it's all filled with 'A's
<br><br><div id="image">
	<img src="images/x64_ace_stack_overview.png" class="responsive">
</div><br>

Now here you can take any address to redirect RIP & the start of shellcode, preferably the first few addresses should be taken. For example, I'll take '0x7fffffffde80'<br><br><br>

Now let's quickly craft our 'payload.py' file. We will use the same format as we had used in the previous tutorial.
<br><br><div id="image">
	<img src="images/x64_ace_incomplete_payload.py.png" class="responsive">
</div><br>

But you can see there is something missing here.<br>
We haven't declared any variable with the name 'buf'. That is because 'buf' will contain our shellcode & now we are generating it using <b>msfvenom</b>. In order to print the date and time, we can simple call '<b>/bin/date</b>', like this :-
<br><br><div id="image">
	<img src="images/x64_ace_msfvenom.png" class="responsive">
</div><br>

Now let's quickly copy this shellcode to our payload file :-
<br><br><div id="image">
	<img src="images/x64_ace_final_payload.py.png" class="responsive">
</div><br>

Now save it and print the output to a new file called 'exploit.txt' [ you can obviously take a different name ]. 
<br><br><div id="image">
	<img src="images/x64_ace_output_exploit.png" class="responsive">
</div><br>

Now let's start GDB & check whether we are able to execute our arbitrary code
<br><br><div id="image">
	<img src="images/x64_ace_PWN!.png" class="responsive">
</div><br>

Voila! You can see we have successfully executed remote code on a modern linux operating system. Though we had to disable some protections to make this, but who cares, in the end our exploit is working flawlessly!

<br><br>
Now that you have understood the concept of Arbitrary Code Execution, I highly encourage you to write your own script and exploit it with different shellcode!!<br>
<br>
<div id="align_right">
Good Luck,<br>
VulnX
<br>
</div>
<hr class="new5">
</font>
</div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script>
var element;
element = document.getElementById("myCookieConsent");

function getCookie(cname) {
  var name = cname + "=";
  var decodedCookie = decodeURIComponent(document.cookie);
  var ca = decodedCookie.split(';');
  for(var i = 0; i <ca.length; i++) {
    var c = ca[i];
    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
}

 var cookieVal = getCookie("cookiePromptShown");

if(cookieVal != "Yes") {
	element.style.display = "block";
}
else {
	element.style.display = "none";
}

</script>

</body>
</html>
